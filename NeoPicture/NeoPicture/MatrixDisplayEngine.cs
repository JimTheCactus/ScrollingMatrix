using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Threading;
using System.Drawing;

namespace NeoPicture
{
    class MatrixQueueItem
    {
        public Color[,] DisplayData;
        public AutoResetEvent SyncHandle;
        public MatrixQueueItem(Color[,] newdata, AutoResetEvent newhandle)
        {
            DisplayData = newdata;
            SyncHandle = newhandle;
        }
    }

    class MatrixDisplayEngine : System.IDisposable 
    {
        SerialPort m_targetport;
        Timer m_refreshtimer;
        Color[,] m_dispbuffer; // This (and m_width) must be locked for access when the timer is running!
        int m_width; // This (and m_dispbuffer) must be locked for access when the timer is running! (Lock it with m_dispbuffer)
        private int m_period;
        Queue<MatrixQueueItem> m_images; // This must be locked for access when the timer is running!

        byte[] m_linebuffer; // Transmit buffer.
        int m_offset; // Keeps the current shift within the display buffer.
        bool m_newdisplay;
        Color[,] m_nextdisplay;
        AutoResetEvent m_pendingsync;

        public MatrixDisplayEngine(string portname, int speed, int period)
        {
            // Initialize our variables
            m_targetport = new SerialPort(portname, speed);
            if (period <=0) {
                throw new System.ArgumentException("Period must be a positive integer.");
            }
            m_period = period;
            m_linebuffer = new byte[8 * 3]; // 24 bytes (just enough for one line.)
            m_dispbuffer = new Color[8, 8]; // One blank screen
            m_width = m_dispbuffer.GetLength(0);
            m_images = new Queue<MatrixQueueItem>();
            m_pendingsync = null;
            m_newdisplay = false;
            m_nextdisplay = new Color[8, 8];
        }

        public void Dispose()
        {
            // Make sure we've shut everything down. (this disposes our timer.)
            this.Stop();
            // Dispose our serial port.
            m_targetport.Dispose();
        }

        public void Reset()
        {
            // Shutdown the timer if it's running
            this.Stop();
            // Dump anything in the queue
            m_images.Clear();
            // Reset the display buffers
            m_dispbuffer = new Color[8, 8];
            m_width = m_dispbuffer.GetLength(0);
            m_newdisplay = false;
            m_pendingsync = null;
            m_offset = 0;
        }

        public bool IsQueueEmpty()
        {
            // If the queue has stuff in it (m_images must be protected for access)
            lock (m_images)
            {
                if (m_images.Count > 0)
                {
                    return false;
                }
                else
                {
                    return true;
                }
            }
        }

        public void DrawImage(string filename, bool blocking = true)
        {
            Bitmap sourceimage; // Holds the source image
            Color pixelcolor; // Holds the current pixel color.
            Color[,] screenimage;

            // Get the source image
            sourceimage = new Bitmap(filename);
            // Allocate a display buffer to hold the converted result.
            screenimage = new Color[sourceimage.Width, 8];

            // For each pixel in the frame (scanning in left to right, top to bottom order)
            for (int y = 0; y < 8; y++)
            {
                for (int x = 0; x < sourceimage.Width; x++)
                {
                    // Get the pixel in the source image...
                    pixelcolor = sourceimage.GetPixel(x, y);
                    // Write the three values to the buffer. (saturate at 254 since 255 is the commit command)
                    screenimage[x,y] = Color.FromArgb(System.Math.Min(pixelcolor.R, (byte)254),
                        System.Math.Min(pixelcolor.G, (byte)254),
                        System.Math.Min(pixelcolor.B, (byte)254));
                }
            }

            // Free the source bitmap
            sourceimage.Dispose();
            // And add the image to the screen or buffer as appropriate.
            this.ChangeDisplay(screenimage, blocking);
        }


        public void DrawText(string Message, bool blocking = true)
        {
            double colorphase;
            byte[] textline;
            Color[,] screenimage;

            // Get the raw codes for the string (we'll need these for the font lookup.)
            textline = System.Text.Encoding.ASCII.GetBytes(Message);
            // Allocate enough buffer for the text (6 columns per character)
            screenimage = new Color[textline.Length * 6, 8];

            // Since the font is stored in per column form, do top to bottom, left to right order.
            for (int x = 0; x < textline.Length * 6; x++)
            {
                // If the current column is the blank at teh end of the character
                if ((x % 6) == 5)
                {
                    // Write a blank to the column
                    for (int y = 0; y < 8; y++)
                    {
                        screenimage[x, y] = Color.FromArgb(0, 0, 0);
                    }
                }
                else
                {
                    // Otherwise, go through each vertical pixel
                    for (int y = 0; y < 8; y++)
                    {
                        // If the font says to draw here (x/6 gets the character number, x%6 gets the character column)
                        if (((font5x8[textline[x / 6], x % 6] >> y) & 0x01) > 0)
                        {
                            // Calculate our spot in the rainbow
                            colorphase = (double)(x) / 12.0 * 2.0 * Math.PI + (double)y / 8.0 * 2.0 * Math.PI;
                            // And then draw it, keeping the R, G, and B one-third of a cycle apart from eachother
                            screenimage[x, y] = Color.FromArgb((int)(254.0 * (.5 + .5 * Math.Sin(colorphase))),
                                (int)(254.0 * (.5 + .5 * Math.Sin(colorphase + 2.0 * (1.0 / 3.0) * Math.PI))),
                                (int)(254.0 * (.5 + .5 * Math.Sin(colorphase + 2.0 * (2.0 / 3.0) * Math.PI))));
                        }
                        else
                        {
                            // If the font says no, draw black.
                            screenimage[x, y] = Color.FromArgb(0, 0, 0);
                        }
                    }
                }
            }

            // And add the image to the screen or buffer as appropriate.
            this.ChangeDisplay(screenimage, blocking);
        }

        public void ChangeDisplay(Color[,] newdata, bool blocking=true) {
            if (newdata.GetLength(0) < 8)
            {
                throw new ArgumentException("Display Buffer must be at least 8 pixels wide.");
            }

            if (newdata.GetLength(1) != 8)
            {
                throw new ArgumentException("Display Buffer must be exactly 8 pixels high.");
            }

            // If we're currently running...
            if (m_refreshtimer != null) {
                AutoResetEvent lockhandle=null;
                // If the user has asked for blocking
                if (blocking)
                {
                    // Create an event to handle it.
                    lockhandle = new AutoResetEvent(false);
                }

                // Add the image to the queue
                lock (m_images)
                {
                    m_images.Enqueue(new MatrixQueueItem(newdata,lockhandle));
                }
                
                // This is not thread-safe. Make sure you don't call stop while you're waiting for this or it will hang forever!
                if (blocking)
                {
                    // and wait for the screen to finish displaying this data.
                    lockhandle.WaitOne();
                    lockhandle.Dispose();
                }
            }
            else {
                // Else, if we're not running, set this data as the initial screen and reset the offset to the left.
                m_dispbuffer = newdata;
                m_width = m_dispbuffer.GetLength(0);
                m_offset = 0;
            }
        }

        public void Start()
        {
            if (m_refreshtimer != null)
            {
                return;
            }

            lock (m_targetport)
            {
                //Open the serial port.
                m_targetport.Open();
                // Write a 0 to the buffer to reset the display.
                m_linebuffer[0] = 0xFF;
                // Transmit the commit command to the bus.
                m_targetport.Write(m_linebuffer, 0, 1);
            }
            // Start the timer.
            m_refreshtimer = new Timer(DisplayWorker, null, 0,m_period);
        }

        public void Stop()
        {
            // If we're not running, then this is moot. Bail.
            if (m_refreshtimer == null)
            {
                return;
            }

            // Setup an event to handle waiting for our cleanup.
            AutoResetEvent cleanup = new AutoResetEvent(false);
            // Ask the timer to clean up.
            m_refreshtimer.Dispose(cleanup);
            // If the timer goes the larger of two extra cycles or 100ms and still hasn't stopped
            if (!cleanup.WaitOne(Math.Min(2 * m_period,100)))
            {
                // Die.
                throw new TimeoutException("Timer failed to stop.");
            }
            // cleanup our timer handle
            m_refreshtimer = null;

            // dispose our wait handle
            cleanup.Dispose();

            // Lastly, if the serial port is open (it should be.)
            if (m_targetport.IsOpen) {
                // Close it.
                m_targetport.Close();
            }
        }

        private void DisplayWorker(object s)
        {
            int lineposition;
            Color curcolor;

            lock (m_targetport)
            {
                if (m_targetport.IsOpen)
                {
                    // For each pixel in the frame (scanning in left to right, top to bottom order)
                    for (int y = 0; y < 8; y++)
                    {
                        // Reset our line pointer
                        lineposition = 0;

                        for (int x = 0 + m_offset; x < 8 + m_offset; x++)
                        {
                            // If we've gone off the end of the buffer but have new data to show
                            if (x >= m_width & m_newdisplay==true)
                            {
                                // get the new data
                                curcolor = m_nextdisplay[x % m_width, y];
                            }
                            else
                            {
                                // Otherwise, just loop the old data
                                curcolor = m_dispbuffer[x % m_width, y];
                            }
                            // Write the color to the buffer
                            m_linebuffer[lineposition++] = (byte) curcolor.R;
                            m_linebuffer[lineposition++] = (byte) curcolor.G;
                            m_linebuffer[lineposition++] = (byte) curcolor.B;
                        }
                        // Write the line to the port
                        m_targetport.Write(m_linebuffer, 0, 8 * 3);
                    }
                    // Write a 0 at the end to mark an end of frame
                    m_linebuffer[0] = 0xFF;
                    // Transmit the commit command to the bus.
                    m_targetport.Write(m_linebuffer, 0, 1);
                }
            }

            // Move to the next column
            m_offset++;

            // If we're at the end?
            if (m_offset >= m_width)
            {
                // Reset the offset
                m_offset = m_offset % m_width;
                if (m_newdisplay)
                {
                    // Rotate the new buffer into the old place
                    m_dispbuffer = m_nextdisplay;
                    m_width = m_dispbuffer.GetLength(0);
                    m_newdisplay = false;

                    // If the current queue item we just shifted in is waiting for a notification
                    if (m_pendingsync != null)
                    {
                        // Send the waiting thread
                        m_pendingsync.Set();
                        m_pendingsync = null;
                    }
                }
            }

            // If we don't have anything currently pending being shifted in...
            if(m_newdisplay == false) { 
                lock (m_images)
                {
                    // Check if there's more out there.
                    if (m_images.Count > 0)
                    {
                        // If there is, grab it out of the queue.
                        MatrixQueueItem item;
                        item = m_images.Dequeue();
                        m_nextdisplay = item.DisplayData;
                        m_pendingsync = item.SyncHandle;
                        m_newdisplay = true;
                    }
                }
            }
        }

        static byte[,] font5x8 = {
            {0x00,0x00,0x00,0x00,0x00},  // 0
            {0x64,0x18,0x04,0x64,0x18},  // 1
            {0x3c,0x40,0x40,0x20,0x7c},  // 2
            //{0x0c,0x30,0x40,0x30,0x0c},  // 3
            {0x0E,0x3F,0x7E,0x3F,0x0E},
            {0x3c,0x40,0x30,0x40,0x3c},
            {0x00,0x3e,0x1c,0x08,0x00},
            {0x04,0x1e,0x1f,0x1e,0x04},
            {0x10,0x3c,0x7c,0x3c,0x10},
            {0x20,0x40,0x3e,0x01,0x02},
            {0x22,0x14,0x08,0x14,0x22},
            {0x00,0x38,0x28,0x38,0x00},
            {0x00,0x10,0x38,0x10,0x00},
            {0x00,0x00,0x10,0x00,0x00},
            {0x08,0x78,0x08,0x00,0x00},
            {0x00,0x15,0x15,0x0a,0x00},
            {0x7f,0x7f,0x09,0x09,0x01},
            {0x10,0x20,0x7f,0x01,0x01},
            {0x04,0x04,0x00,0x01,0x1f},
            {0x00,0x19,0x15,0x12,0x00},
            {0x40,0x60,0x50,0x48,0x44},
            {0x06,0x09,0x09,0x06,0x00},
            {0x0f,0x02,0x01,0x01,0x00},
            {0x00,0x01,0x1f,0x01,0x00},
            {0x44,0x44,0x4a,0x4a,0x51},
            {0x14,0x74,0x1c,0x17,0x14},
            {0x51,0x4a,0x4a,0x44,0x44},
            {0x00,0x00,0x04,0x04,0x04},
            {0x00,0x7c,0x54,0x54,0x44},
            {0x08,0x08,0x2a,0x1c,0x08},
            {0x7c,0x00,0x7c,0x44,0x7c},
            {0x04,0x02,0x7f,0x02,0x04},
            {0x10,0x20,0x7f,0x20,0x10},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x6f,0x00,0x00},
            {0x00,0x07,0x00,0x07,0x00},
            {0x14,0x7f,0x14,0x7f,0x14},
            {0x00,0x07,0x04,0x1e,0x00},
            {0x23,0x13,0x08,0x64,0x62},
            {0x36,0x49,0x56,0x20,0x50},
            {0x00,0x00,0x07,0x00,0x00},
            {0x00,0x1c,0x22,0x41,0x00},
            {0x00,0x41,0x22,0x1c,0x00},
            {0x14,0x08,0x3e,0x08,0x14},
            {0x08,0x08,0x3e,0x08,0x08},
            {0x00,0x50,0x30,0x00,0x00},
            {0x08,0x08,0x08,0x08,0x08},
            {0x00,0x60,0x60,0x00,0x00},
            {0x20,0x10,0x08,0x04,0x02},
            {0x3e,0x51,0x49,0x45,0x3e},
            {0x00,0x42,0x7f,0x40,0x00},
            {0x42,0x61,0x51,0x49,0x46},
            {0x21,0x41,0x45,0x4b,0x31},
            {0x18,0x14,0x12,0x7f,0x10},
            {0x27,0x45,0x45,0x45,0x39},
            {0x3c,0x4a,0x49,0x49,0x30},
            {0x01,0x71,0x09,0x05,0x03},
            {0x36,0x49,0x49,0x49,0x36},
            {0x06,0x49,0x49,0x29,0x1e},
            {0x00,0x36,0x36,0x00,0x00},
            {0x00,0x56,0x36,0x00,0x00},
            {0x08,0x14,0x22,0x41,0x00},
            {0x14,0x14,0x14,0x14,0x14},
            {0x00,0x41,0x22,0x14,0x08},
            {0x02,0x01,0x51,0x09,0x06},            
            {0x3e,0x41,0x5d,0x49,0x4e},
            {0x7e,0x09,0x09,0x09,0x7e},
            {0x7f,0x49,0x49,0x49,0x36},
            {0x3e,0x41,0x41,0x41,0x22},
            {0x7f,0x41,0x41,0x41,0x3e},
            {0x7f,0x49,0x49,0x49,0x41},
            {0x7f,0x09,0x09,0x09,0x01},
            {0x3e,0x41,0x49,0x49,0x7a},
            {0x7f,0x08,0x08,0x08,0x7f},
            {0x00,0x41,0x7f,0x41,0x00},
            {0x20,0x40,0x41,0x3f,0x01},
            {0x7f,0x08,0x14,0x22,0x41},
            {0x7f,0x40,0x40,0x40,0x40},
            {0x7f,0x02,0x0c,0x02,0x7f},
            {0x7f,0x04,0x08,0x10,0x7f},
            {0x3e,0x41,0x41,0x41,0x3e},
            {0x7f,0x09,0x09,0x09,0x06},
            {0x3e,0x41,0x51,0x21,0x5e},
            {0x7f,0x09,0x19,0x29,0x46},
            {0x46,0x49,0x49,0x49,0x31},
            {0x01,0x01,0x7f,0x01,0x01},
            {0x3f,0x40,0x40,0x40,0x3f},
            {0x0f,0x30,0x40,0x30,0x0f},
            {0x3f,0x40,0x30,0x40,0x3f},
            {0x63,0x14,0x08,0x14,0x63},
            {0x07,0x08,0x70,0x08,0x07},
            {0x61,0x51,0x49,0x45,0x43},
            {0x3c,0x4a,0x49,0x29,0x1e},
            {0x02,0x04,0x08,0x10,0x20},
            {0x00,0x41,0x7f,0x00,0x00},
            {0x04,0x02,0x01,0x02,0x04},
            {0x40,0x40,0x40,0x40,0x40},
            {0x00,0x00,0x03,0x04,0x00},
            {0x20,0x54,0x54,0x54,0x78},
            {0x7f,0x48,0x44,0x44,0x38},
            {0x38,0x44,0x44,0x44,0x20},
            {0x38,0x44,0x44,0x48,0x7f},
            {0x38,0x54,0x54,0x54,0x18},
            {0x08,0x7e,0x09,0x01,0x02},
            {0x0c,0x52,0x52,0x52,0x3e},
            {0x7f,0x08,0x04,0x04,0x78},
            {0x00,0x44,0x7d,0x40,0x00},
            {0x20,0x40,0x44,0x3d,0x00},
            {0x00,0x7f,0x10,0x28,0x44},
            {0x00,0x41,0x7f,0x40,0x00},
            {0x7c,0x04,0x18,0x04,0x78},
            {0x7c,0x08,0x04,0x04,0x78},
            {0x38,0x44,0x44,0x44,0x38},
            {0x7c,0x14,0x14,0x14,0x08},
            {0x08,0x14,0x14,0x18,0x7c},
            {0x7c,0x08,0x04,0x04,0x08},
            {0x48,0x54,0x54,0x54,0x20},
            {0x04,0x3f,0x44,0x40,0x20},
            {0x3c,0x40,0x40,0x20,0x7c},
            {0x1c,0x20,0x40,0x20,0x1c},
            {0x3c,0x40,0x30,0x40,0x3c},
            {0x44,0x28,0x10,0x28,0x44},
            {0x0c,0x50,0x50,0x50,0x3c},
            {0x44,0x64,0x54,0x4c,0x44},
            {0x00,0x08,0x36,0x41,0x41},
            {0x00,0x00,0x7f,0x00,0x00},
            {0x41,0x41,0x36,0x08,0x00},
            {0x04,0x02,0x04,0x08,0x04},
            {0x7f,0x6b,0x6b,0x6b,0x7f},
            {0x00,0x7c,0x44,0x7c,0x00},
            {0x00,0x08,0x7c,0x00,0x00},
            {0x00,0x64,0x54,0x48,0x00},
            {0x00,0x44,0x54,0x28,0x00},
            {0x00,0x1c,0x10,0x78,0x00},
            {0x00,0x5c,0x54,0x24,0x00},
            {0x00,0x78,0x54,0x74,0x00},
            {0x00,0x64,0x14,0x0c,0x00},
            {0x00,0x7c,0x54,0x7c,0x00},
            {0x00,0x5c,0x54,0x3c,0x00},
            {0x78,0x24,0x26,0x25,0x78},
            {0x78,0x25,0x26,0x24,0x78},
            {0x70,0x2a,0x29,0x2a,0x70},
            {0x78,0x25,0x24,0x25,0x78},
            {0x20,0x54,0x56,0x55,0x78},
            {0x20,0x55,0x56,0x54,0x78},
            {0x20,0x56,0x55,0x56,0x78},
            {0x20,0x55,0x54,0x55,0x78},
            {0x7c,0x54,0x56,0x55,0x44},
            {0x7c,0x55,0x56,0x54,0x44},
            {0x7c,0x56,0x55,0x56,0x44},
            {0x7c,0x55,0x54,0x55,0x44},
            {0x38,0x54,0x56,0x55,0x18},
            {0x38,0x55,0x56,0x54,0x18},
            {0x38,0x56,0x55,0x56,0x18},
            {0x38,0x55,0x54,0x55,0x18},
            {0x00,0x44,0x7e,0x45,0x00},
            {0x00,0x45,0x7e,0x44,0x00},
            {0x00,0x46,0x7d,0x46,0x00},
            {0x00,0x45,0x7c,0x45,0x00},
            {0x00,0x48,0x7a,0x41,0x00},
            {0x00,0x49,0x7a,0x40,0x00},
            {0x00,0x4a,0x79,0x42,0x00},
            {0x00,0x49,0x78,0x41,0x00},
            {0x38,0x44,0x46,0x45,0x38},
            {0x38,0x45,0x46,0x44,0x38},
            {0x38,0x46,0x45,0x46,0x38},
            {0x38,0x45,0x44,0x45,0x38},
            {0x30,0x48,0x4a,0x49,0x30},
            {0x30,0x49,0x4a,0x48,0x30},
            {0x30,0x4a,0x49,0x4a,0x30},
            {0x30,0x49,0x48,0x49,0x30},
            {0x3c,0x40,0x42,0x41,0x3c},
            {0x3c,0x41,0x42,0x40,0x3c},
            {0x3c,0x42,0x41,0x42,0x3c},
            {0x3c,0x41,0x40,0x41,0x3c},
            {0x3c,0x40,0x42,0x21,0x7c},
            {0x3c,0x41,0x42,0x20,0x7c},
            {0x38,0x42,0x41,0x22,0x78},
            {0x3c,0x41,0x40,0x21,0x7c},
            {0x4e,0x51,0x71,0x11,0x0a},
            {0x58,0x64,0x64,0x24,0x10},
            {0x7c,0x0a,0x11,0x22,0x7d},
            {0x78,0x12,0x09,0x0a,0x71},
            {0x00,0x00,0x04,0x02,0x01},
            {0x01,0x02,0x04,0x00,0x00},
            {0x00,0x02,0x00,0x02,0x00},
            {0x30,0x48,0x45,0x40,0x20},
            {0x00,0x00,0x7b,0x00,0x00},
            {0x38,0x44,0x44,0x38,0x44},
            {0x40,0x3e,0x49,0x49,0x36},
            {0x08,0x04,0x08,0x70,0x0c},
            {0x60,0x50,0x48,0x50,0x60},
            {0x20,0x52,0x55,0x59,0x30},
            {0x38,0x54,0x54,0x54,0x00},
            {0x00,0x00,0x7f,0x41,0x00},
            {0x40,0x22,0x14,0x18,0x60},
            {0x7c,0x20,0x20,0x1c,0x20},
            {0x44,0x3c,0x04,0x7c,0x44},
            {0x40,0x3c,0x12,0x12,0x0c},
            {0x41,0x63,0x55,0x49,0x41},
            {0x38,0x44,0x44,0x3c,0x04},
            {0x08,0x04,0x3c,0x44,0x24},
            {0x08,0x14,0x7f,0x14,0x08},
            {0x4e,0x71,0x01,0x71,0x4e},
            {0x45,0x29,0x11,0x29,0x45},
            {0x0d,0x51,0x51,0x51,0x3d},
            {0x00,0x00,0x05,0x02,0x05},
            {0x40,0x00,0x40,0x00,0x40},
            {0x00,0x08,0x1c,0x3e,0x00},
            {0x1c,0x1c,0x1c,0x00,0x00},
            {0x00,0x70,0x08,0x07,0x00},
            {0x00,0x08,0x08,0x08,0x00},
            {0x00,0x1d,0x15,0x17,0x00},
            {0x00,0x07,0x05,0x07,0x00},
            {0x00,0x11,0x15,0x0a,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x04,0x3c,0x41,0x20,0x00},
            {0x7c,0x16,0x15,0x16,0x08},
            {0x21,0x16,0x08,0x34,0x42},
            {0x7f,0x09,0x1d,0x01,0x03},
            {0x38,0x54,0x54,0x14,0x08},
            {0x00,0x00,0x7c,0x40,0x40},
            {0x7f,0x0e,0x1c,0x38,0x7f},
            {0x41,0x22,0x5d,0x22,0x1c},
            {0x1c,0x3e,0x1c,0x08,0x00},
            {0x7f,0x7f,0x7f,0x7f,0x7f},
            {0x77,0x7b,0x01,0x7b,0x77},
            {0x7f,0x43,0x75,0x43,0x7f},
            {0x7f,0x6f,0x55,0x43,0x7f},
            {0x40,0x40,0x40,0x40,0x40},
            {0x44,0x42,0x5f,0x42,0x44},
            {0x40,0x5e,0x45,0x5e,0x40},
            {0x40,0x48,0x55,0x5e,0x40},
            {0x00,0x04,0x08,0x10,0x20},
            {0x03,0x07,0x0e,0x1c,0x38},
            {0x01,0x03,0x07,0x0f,0x1f},
            {0x7c,0x78,0x70,0x60,0x40},
            {0x08,0x08,0x1c,0x22,0x1c},
            {0x00,0x1c,0x22,0x1c,0x00},
            {0x02,0x00,0x08,0x00,0x20},
            {0x04,0x3e,0x3f,0x3e,0x04},
            {0x10,0x3e,0x7e,0x3e,0x10},
            {0x55,0x2a,0x55,0x2a,0x55},
            {0x24,0x2a,0x7f,0x2a,0x12},
            {0x04,0x1e,0x1f,0x1e,0x04},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00},
            {0x00,0x00,0x00,0x00,0x00} 
        };
    }
}
